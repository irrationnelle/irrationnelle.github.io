---
title: git branch, checkout, merge에 대한 이야기 -1
categories:
 - dev
tags:
 - git
 - version_control
 - merge
---

# git 유감

버전관리로 git 을 쓰지만, git 이 품고 있는 잠재력에 비해 너무나도 활용을 못한다는 생각이 들 때가 많다.

새로운 언어를 접할 때나 프레임워크를 접하면 이것저것 코드도 작성해보고 테스트도 해보며 익숙해지면 되지만,

git 은 아무래도 기존 프로젝트 등에 영향을 미치게 되기 때문에 뭔가를 시도해보기가 껄끄럽다.

혹시라도 파일을 실수로 삭제 한 후 commit 을 했는데 remote 된 원격저장소의 repo 라도 날라가면 어떡하나 싶고.

그래서 보통 git 과 github 등의 원격저장소는 push, pull 용도로만 쓰는 클라우드 저장소 느낌으로만 쓰는 것이 사실.

# 버전관리란 무엇인가

흔히들 버전이라고 하면 v1, v2 등 **특정 소프트웨어의 업그레이드 된 정도** 만을 생각한다.

하지만 리눅스 민트를 보자. 리눅스 민트는 사용하는 쉘에 따라 시나몬 버전이 있고 MATE 버전이 있다.

이 둘은 **v1, v2 처럼 버전을 나누는 것이 아니라 포함된 쉘의 종류가 나뉘면서 버전이 나뉜** 경우다.

git 은 이 두가지 경우를 고려해서 버전 관리를 한다. 첫번째는 `add`와 `commit`을 이용해서, 두번째는 `branch`와 `checkout`을 이용해서

첫번째는 워낙 기본적이고 당연한 이야기라 넘어간다. 이 포스트에서 이야기할 주제는 두번째 경우의 버전관리이다.

# branch 와 checkout

다시 리눅스 민트를 생각하자. 초창기의 리눅스 민트는 시나몬 버전만 만들었다고 가정하면 그동안 리눅스 민트는 시나몬 버전만 버전업이 되었을 것이다.

그런데 어느 개발자가 기존 시나몬 버전의 쉘은 별로인 거 같다면서 쉘을 바꾸자고 건의를 한다. .

하지만 그 의견은 받아들여지지 않고, 시나몬 버전은 여전히 기존의 쉘을 사용한다.

쉘을 바꾸자고 건의한 개발자는 여기서 `git branch MATE` 명령어로 기존 프로젝트에서 파생된 브랜치를 만들고는 `git checkout MATE` 명령어로 개발 버전을 바꾸어 독자적으로 리눅스 민트를 개발할 수 있다.

이 때 MATE 버전의 리눅스 민트가 기존 시나몬 버전의 리눅스 민트보다 뛰어나 역시 대체해야 한다는 이야기가 나오면 이 뻗어나온 브랜치는 기존 시나몬 버전에서 개발하는 `master`로 **합쳐질 것**이다. 보통 이걸 `병합`이라고 하는데, 이 병합이 바로 `git merge` 명령어의 의미이다.

# merge

사실 이 `merge` 개념은 위의 상황으로 봤을 때 그렇게 이해하기 힘든 건 아니다.

근데 막상 써보면 굉장히 당황스러운 일들이 많다.

가령 `master` 브랜치에서 `git merge MATE` 같은 명령어를 입력하면,

충돌이 났다면서 어떤 거는 병합이 되는데 어떤 거는 병합이 된 것도 아니고 안 된 것도 아니고 슈뢰딩거의 고양이 같은 상태가 되기 때문이다.

게다가 리눅스 민트가 지금처럼 MATE 버전과 시나몬 버전을 나누어서 개발하는데,

두 버전 공통으로 발견되는 버그가 생겨서 fix 를 했을 경우에 병합을 하게 되면 어느 한 버전이 다른 한 버전을 완전히 덮어씌우는 것은 아닐까? 하는 걱정도 생긴다.

여기까지 오게되면 결국 걸출한 버전관리 시스템을 두고 과거의 구식 방식으로 폴더를 여러개 만들고, 그 폴더명은 final, finalfinal 등등으로 채워질 것이다. 이런 상황을 피하기 위해 어떻게 merge 를 할 것인가는 다음 포스팅으로.
